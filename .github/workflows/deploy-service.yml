name: Deploy Service to ECS

on:
  repository_dispatch:
    types: [deploy-service]
  workflow_dispatch:
    inputs:
      service:
        description: "Service name (frontend, catalog, user-accounts, text-search, alerts)"
        required: true
      image_uri:
        description: "Full ECR image URI"
        required: true
      container_port:
        description: "Container port (80 for frontend, 8080 for backend)"
        required: false
        default: '8080'
      desired_count:
        description: "Desired task count"
        required: false
        default: '1'
      app_version:
        description: "Application version (defaults to 'manual' for manual deployments)"
        required: false
        default: 'manual'

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ap-southeast-1
      SERVICE: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.service || github.event.inputs.service }}
      IMAGE_URI: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.image_uri || github.event.inputs.image_uri }}
      CONTAINER_PORT: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.container_port || github.event.inputs.container_port || '8080' }}
      DESIRED_COUNT: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.desired_count || github.event.inputs.desired_count || '1' }}
      APP_ENV: beta
      APP_VERSION: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.app_version || github.event.inputs.app_version || 'manual' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Terraform init
        working-directory: terraform-service-deploy
        run: |
          terraform init -input=false -reconfigure \
            -backend-config="key=services-tf-state/deployments/${SERVICE}.tfstate"

      - name: Set service-specific secrets
        id: secrets
        run: |
          # Determine service type based on service name
          if [ "$SERVICE" = "frontend" ]; then
            SERVICE_TYPE="frontend"
          else
            SERVICE_TYPE="backend"
          fi
          
          case "$SERVICE_TYPE" in
            frontend)
              echo "log_group=/ecs/ph-shoes-services-automation-$SERVICE" >> $GITHUB_OUTPUT
              echo "exec_role=${{ secrets.FRONTEND_EXEC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              echo "task_role=${{ secrets.FRONTEND_TASK_ROLE_ARN }}" >> $GITHUB_OUTPUT
              echo "port=8080" >> $GITHUB_OUTPUT
              echo "host_port=8081" >> $GITHUB_OUTPUT
              echo "memory=128" >> $GITHUB_OUTPUT
              echo "environment={\"APP_ENV\":\"${{ env.APP_ENV }}\",\"APP_VERSION\":\"${{ env.APP_VERSION }}\"}" >> $GITHUB_OUTPUT
              ;;
            backend)
              echo "log_group=/ecs/ph-shoes-services-automation-$SERVICE" >> $GITHUB_OUTPUT
              echo "exec_role=${{ secrets.BACKEND_EXEC_ROLE_ARN }}" >> $GITHUB_OUTPUT
              echo "task_role=${{ secrets.BACKEND_TASK_ROLE_ARN }}" >> $GITHUB_OUTPUT
              echo "port=8080" >> $GITHUB_OUTPUT
              echo "memory=456" >> $GITHUB_OUTPUT
              
              # Set host port based on service name
              case "$SERVICE" in
                catalog)
                  echo "host_port=8083" >> $GITHUB_OUTPUT
                  # Create environment JSON using jq for proper escaping
                  jq -n \
                    --arg app_env "${{ env.APP_ENV }}" \
                    --arg app_version "${{ env.APP_VERSION }}" \
                    --arg spring_profiles "${{ secrets.SPRING_PROFILES_ACTIVE }}" \
                    --arg datasource_username "${{ secrets.SPRING_DATASOURCE_USERNAME }}" \
                    --arg datasource_password "${{ secrets.SPRING_DATASOURCE_PASSWORD }}" \
                    --arg snowflake_account "${{ secrets.SNOWFLAKE_ACCOUNT }}" \
                    --arg snowflake_warehouse "${{ secrets.SNOWFLAKE_WAREHOUSE }}" \
                    --arg snowflake_database "${{ secrets.SNOWFLAKE_DATABASE }}" \
                    --arg snowflake_schema "${{ secrets.SNOWFLAKE_SCHEMA }}" \
                    --arg snowflake_role "${{ secrets.SNOWFLAKE_ROLE }}" \
                    --arg snowflake_token "${{ secrets.SNOWFLAKE_TOKEN }}" \
                    '{
                      "APP_ENV": $app_env,
                      "APP_VERSION": $app_version,
                      "SPRING_PROFILES_ACTIVE": $spring_profiles,
                      "SPRING_DATASOURCE_USERNAME": $datasource_username,
                      "SPRING_DATASOURCE_PASSWORD": $datasource_password,
                      "SNOWFLAKE_ACCOUNT": $snowflake_account,
                      "SNOWFLAKE_WAREHOUSE": $snowflake_warehouse,
                      "SNOWFLAKE_DATABASE": $snowflake_database,
                      "SNOWFLAKE_SCHEMA": $snowflake_schema,
                      "SNOWFLAKE_ROLE": $snowflake_role,
                      "SNOWFLAKE_TOKEN": $snowflake_token
                    }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
                  ;;
                user-accounts)
                  echo "host_port=8082" >> $GITHUB_OUTPUT
                  # Create environment JSON with HTTPS URLs and crypto secrets for user-accounts service
                  jq -n \
                    --arg app_env "${{ env.APP_ENV }}" \
                    --arg app_version "${{ env.APP_VERSION }}" \
                    --arg spring_profiles "${{ secrets.SPRING_PROFILES_ACTIVE }}" \
                    --arg hmac_pepper_b64 "${{ secrets.HMAC_PEPPER_B64 }}" \
                    --arg aes_key_b64 "${{ secrets.AES_KEY_B64 }}" \
                    --arg hmac_legacy_peppers_b64 "${{ secrets.HMAC_LEGACY_PEPPERS_B64 }}" \
                    --arg jwt_secret "${{ secrets.JWT_SECRET }}" \
                    '{
                      "APP_ENV": $app_env,
                      "APP_VERSION": $app_version,
                      "SPRING_PROFILES_ACTIVE": $spring_profiles,
                      "HMAC_PEPPER_B64": $hmac_pepper_b64,
                      "AES_KEY_B64": $aes_key_b64,
                      "HMAC_LEGACY_PEPPERS_B64": $hmac_legacy_peppers_b64,
                      "JWT_SECRET": $jwt_secret,
                      "NOTIFICATION_UNSUBSCRIBE_LINK": "https://accounts.phshoesproject.com/api/v1/user-accounts/unsubscribe",
                      "VERIFICATION_LINK_BASE_URL": "https://accounts.phshoesproject.com/api/v1/verify/email",
                      "VERIFICATION_NOT_ME_URL": "https://accounts.phshoesproject.com/api/v1/verify/email/not-me"
                    }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
                  ;;
                text-search)
                  echo "host_port=8084" >> $GITHUB_OUTPUT
                  # Create environment JSON for text-search service
                  jq -n \
                    --arg app_env "${{ env.APP_ENV }}" \
                    --arg app_version "${{ env.APP_VERSION }}" \
                    --arg spring_profiles "${{ secrets.SPRING_PROFILES_ACTIVE }}" \
                    --arg datasource_username "${{ secrets.SPRING_DATASOURCE_USERNAME }}" \
                    --arg datasource_password "${{ secrets.SPRING_DATASOURCE_PASSWORD }}" \
                    --arg snowflake_account "${{ secrets.SNOWFLAKE_ACCOUNT }}" \
                    --arg snowflake_warehouse "${{ secrets.SNOWFLAKE_WAREHOUSE }}" \
                    --arg snowflake_database "${{ secrets.SNOWFLAKE_DATABASE }}" \
                    --arg snowflake_schema "${{ secrets.SNOWFLAKE_SCHEMA }}" \
                    --arg snowflake_role "${{ secrets.SNOWFLAKE_ROLE }}" \
                    --arg snowflake_token "${{ secrets.SNOWFLAKE_TOKEN }}" \
                    '{
                      "APP_ENV": $app_env,
                      "APP_VERSION": $app_version,
                      "SPRING_PROFILES_ACTIVE": $spring_profiles,
                      "SPRING_DATASOURCE_USERNAME": $datasource_username,
                      "SPRING_DATASOURCE_PASSWORD": $datasource_password,
                      "SNOWFLAKE_ACCOUNT": $snowflake_account,
                      "SNOWFLAKE_WAREHOUSE": $snowflake_warehouse,
                      "SNOWFLAKE_DATABASE": $snowflake_database,
                      "SNOWFLAKE_SCHEMA": $snowflake_schema,
                      "SNOWFLAKE_ROLE": $snowflake_role,
                      "SNOWFLAKE_TOKEN": $snowflake_token
                    }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
                  ;;
                alerts)
                  echo "host_port=8085" >> $GITHUB_OUTPUT
                  # Create environment JSON with HTTPS URLs and security variables for alerts service
                  jq -n \
                    --arg app_env "${{ env.APP_ENV }}" \
                    --arg app_version "${{ env.APP_VERSION }}" \
                    --arg aws_region "${{ env.AWS_REGION }}" \
                    --arg spring_profiles "${{ secrets.SPRING_PROFILES_ACTIVE }}" \
                    --arg datasource_username "${{ secrets.SPRING_DATASOURCE_USERNAME }}" \
                    --arg datasource_password "${{ secrets.SPRING_DATASOURCE_PASSWORD }}" \
                    --arg snowflake_account "${{ secrets.SNOWFLAKE_ACCOUNT }}" \
                    --arg snowflake_warehouse "${{ secrets.SNOWFLAKE_WAREHOUSE }}" \
                    --arg snowflake_database "${{ secrets.SNOWFLAKE_DATABASE }}" \
                    --arg snowflake_schema "${{ secrets.SNOWFLAKE_SCHEMA }}" \
                    --arg snowflake_role "${{ secrets.SNOWFLAKE_ROLE }}" \
                    --arg snowflake_token "${{ secrets.SNOWFLAKE_TOKEN }}" \
                    --arg hmac_pepper_b64 "${{ secrets.HMAC_PEPPER_B64 }}" \
                    --arg aes_key_b64 "${{ secrets.AES_KEY_B64 }}" \
                    --arg hmac_legacy_peppers_b64 "${{ secrets.HMAC_LEGACY_PEPPERS_B64 }}" \
                    --arg jwt_secret "${{ secrets.JWT_SECRET }}" \
                    '{
                      "APP_ENV": $app_env,
                      "APP_VERSION": $app_version,
                      "AWS_REGION": $aws_region,
                      "SPRING_PROFILES_ACTIVE": $spring_profiles,
                      "SPRING_DATASOURCE_USERNAME": $datasource_username,
                      "SPRING_DATASOURCE_PASSWORD": $datasource_password,
                      "SNOWFLAKE_ACCOUNT": $snowflake_account,
                      "SNOWFLAKE_WAREHOUSE": $snowflake_warehouse,
                      "SNOWFLAKE_DATABASE": $snowflake_database,
                      "SNOWFLAKE_SCHEMA": $snowflake_schema,
                      "SNOWFLAKE_ROLE": $snowflake_role,
                      "SNOWFLAKE_TOKEN": $snowflake_token,
                      "HMAC_PEPPER_B64": $hmac_pepper_b64,
                      "AES_KEY_B64": $aes_key_b64,
                      "HMAC_LEGACY_PEPPERS_B64": $hmac_legacy_peppers_b64,
                      "JWT_SECRET": $jwt_secret,
                      "NOTIFICATION_UNSUBSCRIBE_LINK": "https://accounts.phshoesproject.com/api/v1/user-accounts/unsubscribe",
                      "VERIFICATION_LINK": "https://accounts.phshoesproject.com/verify"
                    }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
                  ;;
                *)
                  echo "host_port=${CONTAINER_PORT}" >> $GITHUB_OUTPUT
                  echo "environment={\"APP_ENV\":\"${{ env.APP_ENV }}\",\"APP_VERSION\":\"${{ env.APP_VERSION }}\"}" >> $GITHUB_OUTPUT
                  ;;
              esac
              ;;
          esac

      - name: Deploy via Terraform
        working-directory: terraform-service-deploy
        env:
          TF_VAR_service_id: ${{ env.SERVICE }}
          TF_VAR_service_name: ph-shoes-services-automation-${{ env.SERVICE }}
          TF_VAR_container_image: ${{ env.IMAGE_URI }}
          TF_VAR_container_port: ${{ steps.secrets.outputs.port }}
          TF_VAR_host_port: ${{ steps.secrets.outputs.host_port }}
          TF_VAR_memory: ${{ steps.secrets.outputs.memory }}
          TF_VAR_desired_count: ${{ env.DESIRED_COUNT }}
          TF_VAR_log_group_name: ${{ steps.secrets.outputs.log_group }}
          TF_VAR_execution_role_arn: ${{ steps.secrets.outputs.exec_role }}
          TF_VAR_task_role_arn: ${{ steps.secrets.outputs.task_role }}
          TF_VAR_environment: ${{ steps.secrets.outputs.environment || '{"APP_ENV":"${{ env.APP_ENV }}","APP_VERSION":"${{ env.APP_VERSION }}"}' }}
        run: |
          echo "Deploying $SERVICE with image $IMAGE_URI on port $TF_VAR_container_port (memory: $TF_VAR_memory MB)"
          terraform apply -input=false -auto-approve

      - name: DNS update info (frontend only)
        if: env.SERVICE == 'frontend'
        run: |
          echo "‚úÖ Frontend deployment completed"
          echo "üìù DNS will be automatically updated by scheduled workflow within 15 minutes"
          echo "üîç Or manually trigger 'Auto DNS Update' workflow for immediate update"

      - name: Wait for deployment health check
        run: |
          if [ "${{ env.SERVICE }}" = "frontend" ]; then
            echo "Checking ECS service status..."
            
            for i in {1..30}; do
              SERVICE_INFO=$(aws ecs describe-services \
                --cluster ph-shoes-services-ecs \
                --services ph-shoes-services-automation-frontend \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].{running:runningCount,desired:desiredCount,deployments:deployments[?status==`PRIMARY`].{status:status,rolloutState:rolloutState}}' --output json)
              
              RUNNING=$(echo $SERVICE_INFO | jq -r '.running')
              DESIRED=$(echo $SERVICE_INFO | jq -r '.desired')
              ROLLOUT_STATE=$(echo $SERVICE_INFO | jq -r '.deployments[0].rolloutState // "PENDING"')
              
              echo "ECS Status: $RUNNING/$DESIRED tasks running, Rollout: $ROLLOUT_STATE"
              
              if [ "$RUNNING" = "$DESIRED" ] && [ "$RUNNING" != "0" ] && [ "$ROLLOUT_STATE" = "COMPLETED" ]; then
                echo "‚úÖ ECS tasks are running, checking URL health..."
                
                URL="https://phshoesproject.com"
                STATUS=$(curl -s -o /dev/null -w "%{http_code}" $URL || echo "000")
                
                if [ "$STATUS" = "200" ]; then
                  echo "‚úÖ Site is healthy (HTTP $STATUS)"
                  exit 0
                else
                  echo "URL returned HTTP $STATUS, waiting..."
                fi
              fi
              
              echo "Attempt $i/30 - waiting 30s..."
              sleep 30
            done
            
            echo "‚ùå Deployment failed - site not healthy after 15 minutes"
            exit 1
          else
            echo "Non-frontend service - showing status:"
            aws ecs describe-services \
              --cluster ph-shoes-services-ecs \
              --services ph-shoes-services-automation-${{ env.SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].{desired:desiredCount,running:runningCount,pending:pendingCount}'
          fi
