name: Deploy Service to ECS

on:
  repository_dispatch:
    types: [deploy-service]
  workflow_dispatch:
    inputs:
      service:
        description: "Service name (frontend, catalog, user-accounts, text-search, alerts)"
        required: true
      image_uri:
        description: "Full ECR image URI"
        required: true
      container_port:
        description: "Container port (80 for frontend, 8080 for backend)"
        required: false
        default: '8080'
      desired_count:
        description: "Desired task count"
        required: false
        default: '1'
      app_version:
        description: "Application version (defaults to 'manual' for manual deployments)"
        required: false
        default: 'manual'

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ap-southeast-1
      SERVICE: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.service || github.event.inputs.service }}
      IMAGE_URI: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.image_uri || github.event.inputs.image_uri }}
      CONTAINER_PORT: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.container_port || github.event.inputs.container_port || '8080' }}
      DESIRED_COUNT: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.desired_count || github.event.inputs.desired_count || '1' }}
      APP_ENV: beta
      APP_VERSION: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.app_version || github.event.inputs.app_version || 'manual' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Auto-scale cluster if needed
        run: |
          echo "ğŸ” Checking if cluster needs to be scaled up..."
          CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ph-shoes-services-ecs-asg \
            --region ${{ env.AWS_REGION }} \
            --query 'AutoScalingGroups[0].DesiredCapacity' \
            --output text)
          
          if [ "$CURRENT_CAPACITY" = "0" ]; then
            echo "âš¡ Cluster is at 0 capacity, scaling up to 1 instance..."
            aws autoscaling set-desired-capacity \
              --auto-scaling-group-name ph-shoes-services-ecs-asg \
              --desired-capacity 1 \
              --region ${{ env.AWS_REGION }}
            
            echo "â³ Waiting 90 seconds for instance to start and register with ECS..."
            sleep 90
            echo "âœ… Cluster scaled up and ready for deployment"
          else
            echo "âœ… Cluster already has $CURRENT_CAPACITY instance(s) running"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Terraform init
        working-directory: terraform-service-deploy
        run: |
          terraform init -input=false -reconfigure \
            -backend-config="key=services-tf-state/deployments/${SERVICE}.tfstate"

      - name: Set service configuration
        id: secrets
        run: |
          # Set common configuration
          echo "log_group=/ecs/ph-shoes-services-automation-$SERVICE" >> $GITHUB_OUTPUT
          
          # Set service type and basic config
          if [ "$SERVICE" = "frontend" ]; then
            echo "exec_role=${{ secrets.FRONTEND_EXEC_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "task_role=${{ secrets.FRONTEND_TASK_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "port=80" >> $GITHUB_OUTPUT
            echo "host_port=8080" >> $GITHUB_OUTPUT
            echo "memory=128" >> $GITHUB_OUTPUT
            
            # Frontend environment (minimal)
            jq -n \
              --arg app_env "${{ env.APP_ENV }}" \
              --arg app_version "${{ env.APP_VERSION }}" \
              '{
                "APP_ENV": $app_env,
                "APP_VERSION": $app_version
              }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
          else
            # Backend services - shared configuration
            echo "exec_role=${{ secrets.BACKEND_EXEC_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "task_role=${{ secrets.BACKEND_TASK_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "port=8080" >> $GITHUB_OUTPUT
            echo "memory=300" >> $GITHUB_OUTPUT
            
            # Set service-specific host ports and container ports
            case "$SERVICE" in
              catalog) echo "host_port=8083" >> $GITHUB_OUTPUT ;;
              user-accounts) echo "host_port=8082" >> $GITHUB_OUTPUT; echo "port=8082" >> $GITHUB_OUTPUT ;;
              text-search) echo "host_port=8084" >> $GITHUB_OUTPUT; echo "port=8084" >> $GITHUB_OUTPUT ;;
              alerts) echo "host_port=8085" >> $GITHUB_OUTPUT ;;
              *) echo "host_port=8080" >> $GITHUB_OUTPUT ;;
            esac
            
            # Shared backend environment (all secrets included)
            # Set service-specific SERVER_PORT
            case "$SERVICE" in
              user-accounts) SERVER_PORT="8082" ;;
              text-search) SERVER_PORT="8084" ;;
              *) SERVER_PORT="8080" ;;
            esac

            # Preserve existing image defaults while applying JVM right-sizing
            case "$SERVICE" in
              catalog) JAVA_TOOL_OPTIONS="--add-opens=java.base/java.nio=ALL-UNNAMED -Dsnowflake.jdbc.enableArrow=false -XX:+ExitOnOutOfMemoryError -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp -XX:MaxRAMPercentage=70.0 -XX:+UseSerialGC -Xss256k" ;;
              *) JAVA_TOOL_OPTIONS="-XX:+ExitOnOutOfMemoryError -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp -XX:MaxRAMPercentage=70.0 -XX:+UseSerialGC -Xss256k" ;;
            esac

            jq -n \
              --arg app_env "${{ env.APP_ENV }}" \
              --arg app_version "${{ env.APP_VERSION }}" \
              --arg aws_region "${{ env.AWS_REGION }}" \
              --arg server_port "$SERVER_PORT" \
              --arg port "$SERVER_PORT" \
              --arg spring_profiles "${{ secrets.SPRING_PROFILES_ACTIVE }}" \
              --arg java_tool_options "$JAVA_TOOL_OPTIONS" \
              --arg datasource_username "${{ secrets.SPRING_DATASOURCE_USERNAME }}" \
              --arg datasource_password "${{ secrets.SPRING_DATASOURCE_PASSWORD }}" \
              --arg datasource_driver_class_name "${{ vars.SPRING_DATASOURCE_DRIVER_CLASS_NAME }}" \
              --arg snowflake_account "${{ secrets.SNOWFLAKE_ACCOUNT }}" \
              --arg snowflake_warehouse "${{ secrets.SNOWFLAKE_WAREHOUSE }}" \
              --arg snowflake_database "${{ secrets.SNOWFLAKE_DATABASE }}" \
              --arg snowflake_schema "${{ secrets.SNOWFLAKE_SCHEMA }}" \
              --arg snowflake_role "${{ secrets.SNOWFLAKE_ROLE }}" \
              --arg snowflake_token "${{ secrets.SNOWFLAKE_TOKEN }}" \
              --arg log_level_root "${{ vars.LOG_LEVEL_ROOT }}" \
              --arg spring_jpa_show_sql "${{ vars.SPRING_JPA_SHOW_SQL }}" \
              --arg cors_allowed_origins "${{ vars.CORS_ALLOWED_ORIGINS }}" \
              --arg cors_allowed_methods "${{ vars.CORS_ALLOWED_METHODS }}" \
              --arg cors_allowed_headers "${{ vars.CORS_ALLOWED_HEADERS }}" \
              --arg cors_allow_credentials "${{ vars.CORS_ALLOW_CREDENTIALS }}" \
              --arg cors_max_age "${{ vars.CORS_MAX_AGE }}" \
              --arg db_pool_max_size "${{ vars.DB_POOL_MAX_SIZE }}" \
              --arg db_pool_min_idle "${{ vars.DB_POOL_MIN_IDLE }}" \
              --arg db_pool_idle_timeout "${{ vars.DB_POOL_IDLE_TIMEOUT }}" \
              --arg db_pool_connection_timeout "${{ vars.DB_POOL_CONNECTION_TIMEOUT }}" \
              --arg db_pool_init_fail_timeout "${{ vars.DB_POOL_INIT_FAIL_TIMEOUT }}" \
              --arg snowflake_enable_arrow_resultset "${{ vars.SNOWFLAKE_ENABLE_ARROW_RESULTSET }}" \
              --arg phshoes_security_email_enabled "${{ vars.PHSHOES_SECURITY_EMAIL_ENABLED }}" \
              --arg rate_limit_enabled "${{ vars.PHSHOES_API_RATE_LIMIT_ENABLED }}" \
              --arg rate_limit_window "${{ vars.PHSHOES_API_RATE_LIMIT_WINDOW }}" \
              --arg rate_limit_global_enabled "${{ vars.PHSHOES_API_RATE_LIMIT_GLOBAL_ENABLED }}" \
              --arg rate_limit_global_limit "${{ vars.PHSHOES_API_RATE_LIMIT_GLOBAL_LIMIT }}" \
              --arg rate_limit_per_ip_enabled "${{ vars.PHSHOES_API_RATE_LIMIT_PER_IP_ENABLED }}" \
              --arg rate_limit_per_ip_limit "${{ vars.PHSHOES_API_RATE_LIMIT_PER_IP_LIMIT }}" \
              --arg rate_limit_per_user_enabled "${{ vars.PHSHOES_API_RATE_LIMIT_PER_USER_ENABLED }}" \
              --arg rate_limit_per_user_limit "${{ vars.PHSHOES_API_RATE_LIMIT_PER_USER_LIMIT }}" \
              --arg hmac_pepper_b64 "${{ secrets.HMAC_PEPPER_B64 }}" \
              --arg aes_key_b64 "${{ secrets.AES_KEY_B64 }}" \
              --arg hmac_legacy_peppers_b64 "${{ secrets.HMAC_LEGACY_PEPPERS_B64 }}" \
              --arg jwt_secret "${{ secrets.JWT_SECRET }}" \
              --arg openai_api_key "${{ secrets.OPENAI_API_KEY }}" \
              --arg openai_org_id "${{ secrets.OPENAI_ORG_ID }}" \
              --arg openai_project_id "${{ secrets.OPENAI_PROJECT_ID }}" \
              '{
                "APP_ENV": $app_env,
                "APP_VERSION": $app_version,
                "AWS_REGION": $aws_region,
                "SERVER_PORT": $server_port,
                "PORT": $port,
                "SPRING_PROFILES_ACTIVE": $spring_profiles,
                "JAVA_TOOL_OPTIONS": $java_tool_options,
                "SERVER_TOMCAT_THREADS_MAX": "10",
                "SPRING_MAIN_LAZY_INITIALIZATION": "true",
                "SPRING_DATASOURCE_USERNAME": $datasource_username,
                "SPRING_DATASOURCE_PASSWORD": $datasource_password,
                "SPRING_DATASOURCE_DRIVER_CLASS_NAME": $datasource_driver_class_name,
                "SNOWFLAKE_ACCOUNT": $snowflake_account,
                "SNOWFLAKE_WAREHOUSE": $snowflake_warehouse,
                "SNOWFLAKE_DATABASE": $snowflake_database,
                "SNOWFLAKE_SCHEMA": $snowflake_schema,
                "SNOWFLAKE_ROLE": $snowflake_role,
                "SNOWFLAKE_TOKEN": $snowflake_token,
                "LOG_LEVEL_ROOT": $log_level_root,
                "SPRING_JPA_SHOW_SQL": $spring_jpa_show_sql,
                "CORS_ALLOWED_ORIGINS": $cors_allowed_origins,
                "CORS_ALLOWED_METHODS": $cors_allowed_methods,
                "CORS_ALLOWED_HEADERS": $cors_allowed_headers,
                "CORS_ALLOW_CREDENTIALS": $cors_allow_credentials,
                "CORS_MAX_AGE": $cors_max_age,
                "DB_POOL_MAX_SIZE": $db_pool_max_size,
                "DB_POOL_MIN_IDLE": $db_pool_min_idle,
                "DB_POOL_IDLE_TIMEOUT": $db_pool_idle_timeout,
                "DB_POOL_CONNECTION_TIMEOUT": $db_pool_connection_timeout,
                "DB_POOL_INIT_FAIL_TIMEOUT": $db_pool_init_fail_timeout,
                "SNOWFLAKE_ENABLE_ARROW_RESULTSET": $snowflake_enable_arrow_resultset,
                "PHSHOES_SECURITY_EMAIL_ENABLED": $phshoes_security_email_enabled,
                "PHSHOES_API_RATE_LIMIT_ENABLED": $rate_limit_enabled,
                "PHSHOES_API_RATE_LIMIT_WINDOW": $rate_limit_window,
                "PHSHOES_API_RATE_LIMIT_GLOBAL_ENABLED": $rate_limit_global_enabled,
                "PHSHOES_API_RATE_LIMIT_GLOBAL_LIMIT": $rate_limit_global_limit,
                "PHSHOES_API_RATE_LIMIT_PER_IP_ENABLED": $rate_limit_per_ip_enabled,
                "PHSHOES_API_RATE_LIMIT_PER_IP_LIMIT": $rate_limit_per_ip_limit,
                "PHSHOES_API_RATE_LIMIT_PER_USER_ENABLED": $rate_limit_per_user_enabled,
                "PHSHOES_API_RATE_LIMIT_PER_USER_LIMIT": $rate_limit_per_user_limit,
                "HMAC_PEPPER_B64": $hmac_pepper_b64,
                "AES_KEY_B64": $aes_key_b64,
                "HMAC_LEGACY_PEPPERS_B64": $hmac_legacy_peppers_b64,
                "JWT_SECRET": $jwt_secret,
                "OPENAI_API_KEY": $openai_api_key,
                "OPENAI_ORG_ID": $openai_org_id,
                "OPENAI_PROJECT_ID": $openai_project_id,
                "NOTIFICATION_UNSUBSCRIBE_LINK": "https://accounts.phshoesproject.com/api/v1/user-accounts/unsubscribe",
                "VERIFICATION_LINK_BASE_URL": "https://accounts.phshoesproject.com/api/v1/verify/email",
                "VERIFICATION_NOT_ME_URL": "https://accounts.phshoesproject.com/api/v1/verify/email/not-me",
                "VERIFICATION_LINK": "https://accounts.phshoesproject.com/verify"
              }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
          fi

      - name: Deploy via Terraform
        working-directory: terraform-service-deploy
        env:
          TF_VAR_service_id: ${{ env.SERVICE }}
          TF_VAR_service_name: ph-shoes-services-automation-${{ env.SERVICE }}
          TF_VAR_container_image: ${{ env.IMAGE_URI }}
          TF_VAR_container_port: ${{ steps.secrets.outputs.port }}
          TF_VAR_host_port: ${{ steps.secrets.outputs.host_port }}
          TF_VAR_memory: ${{ steps.secrets.outputs.memory }}
          TF_VAR_desired_count: ${{ env.DESIRED_COUNT }}
          TF_VAR_log_group_name: ${{ steps.secrets.outputs.log_group }}
          TF_VAR_execution_role_arn: ${{ steps.secrets.outputs.exec_role }}
          TF_VAR_task_role_arn: ${{ steps.secrets.outputs.task_role }}
          TF_VAR_environment: ${{ steps.secrets.outputs.environment || '{"APP_ENV":"${{ env.APP_ENV }}","APP_VERSION":"${{ env.APP_VERSION }}"}' }}
        run: |
          echo "Deploying $SERVICE with image $IMAGE_URI on port $TF_VAR_container_port (memory: $TF_VAR_memory MB)"
          terraform apply -input=false -auto-approve

      - name: Check for missing backend services (frontend only)
        if: env.SERVICE == 'frontend'
        run: |
          echo "ğŸ” Checking if backend services are running..."
          
          # Check if any backend services are missing
          MISSING_SERVICES=""
          
          # Check each backend service
          for service in catalog user-accounts alerts; do
            RUNNING=$(aws ecs describe-services \
              --cluster ph-shoes-services-ecs \
              --services ph-shoes-services-automation-$service \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].runningCount' \
              --output text 2>/dev/null || echo "0")
            
            if [ "$RUNNING" = "0" ] || [ "$RUNNING" = "None" ]; then
              MISSING_SERVICES="$MISSING_SERVICES $service"
              echo "âŒ Service $service is not running"
            else
              echo "âœ… Service $service is running ($RUNNING tasks)"
            fi
          done
          
          if [ -n "$MISSING_SERVICES" ]; then
            echo "âš ï¸  Warning: Backend services are not running:$MISSING_SERVICES"
            echo "ğŸ’¡ Frontend will work but API calls may fail with 502 errors"
            echo "ğŸ”§ To fix: Deploy the missing backend services or use the 'Deploy All Services' workflow"
            echo ""
            echo "missing_backends=true" >> $GITHUB_ENV
          else
            echo "âœ… All backend services are running"
            echo "missing_backends=false" >> $GITHUB_ENV
          fi

      - name: Wait for ECS rollout completion
        id: deployment_status
        run: |
          echo "ğŸ”„ Waiting for ECS rollout to complete for service: ${{ env.SERVICE }}"
          
          # Wait for ECS service to reach stable state
          for i in {1..30}; do
            SERVICE_INFO=$(aws ecs describe-services \
              --cluster ph-shoes-services-ecs \
              --services ph-shoes-services-automation-${{ env.SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].{running:runningCount,desired:desiredCount,deployments:deployments[?status==`PRIMARY`].{status:status,rolloutState:rolloutState}}' --output json)
            
            RUNNING=$(echo $SERVICE_INFO | jq -r '.running')
            DESIRED=$(echo $SERVICE_INFO | jq -r '.desired')
            ROLLOUT_STATE=$(echo $SERVICE_INFO | jq -r '.deployments[0].rolloutState // "PENDING"')
            
            echo "ECS Status: $RUNNING/$DESIRED tasks running, Rollout: $ROLLOUT_STATE"
            
            # Check if rollout is complete
            if [ "$RUNNING" = "$DESIRED" ] && [ "$RUNNING" != "0" ] && [ "$ROLLOUT_STATE" = "COMPLETED" ]; then
              echo "âœ… ECS rollout completed successfully"
              echo "deployment_success=true" >> $GITHUB_OUTPUT
              echo "deployment_timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
              break
            fi
            
            echo "Attempt $i/30 - waiting 30s..."
            sleep 30
          done
          
          # Final check
          if [ "$ROLLOUT_STATE" != "COMPLETED" ] || [ "$RUNNING" != "$DESIRED" ]; then
            echo "âŒ ECS rollout failed or timed out"
            echo "deployment_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      # DNS updates are now handled manually via auto-dns-update.yml workflow

      - name: Wait for DNS propagation
        if: steps.deployment_status.outputs.deployment_success == 'true'
        run: |
          echo "â³ Waiting for DNS update to complete and propagate..."
          echo "ğŸ”„ This ensures health checks hit the correct instance"
          sleep 90  # Give DNS update workflow time to complete and propagate

      - name: Health check validation
        id: health_check
        if: steps.deployment_status.outputs.deployment_success == 'true'
        run: |
          echo "ğŸ¥ Performing health check for service: ${{ env.SERVICE }}"
          echo "âœ… DNS should now point to the correct instance"
          
          # Set health check URL based on service type
          case "${{ env.SERVICE }}" in
            frontend)
              HEALTH_URL="https://phshoesproject.com"
              EXPECTED_STATUS="200"
              ;;
            user-accounts)
              HEALTH_URL="https://accounts.phshoesproject.com/api/v1/system/status"
              EXPECTED_STATUS="200"
              ;;
            catalog)
              HEALTH_URL="https://catalog.phshoesproject.com/api/v1/system/status"
              EXPECTED_STATUS="200"
              ;;
            alerts)
              HEALTH_URL="https://alerts.phshoesproject.com/api/v1/system/status"
              EXPECTED_STATUS="200"
              ;;
            text-search)
              HEALTH_URL="https://text-search.phshoesproject.com/api/v1/system/status"
              EXPECTED_STATUS="200"
              ;;
            *)
              echo "âš ï¸ Unknown service type, skipping health check"
              echo "health_check_passed=true" >> $GITHUB_OUTPUT
              exit 0
              ;;
          esac
          
          echo "Testing health endpoint: $HEALTH_URL"
          
          # Perform health check with retries
          HEALTH_PASSED=false
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$HEALTH_URL" || echo "000")
            echo "Health check attempt $i/10: HTTP $STATUS"
            
            if [ "$STATUS" = "$EXPECTED_STATUS" ]; then
              echo "âœ… Health check passed (HTTP $STATUS)"
              HEALTH_PASSED=true
              break
            elif [ "$STATUS" = "522" ]; then
              echo "ğŸš¨ Still getting 522 error - DNS may need more time to propagate"
            elif [ "$STATUS" = "000" ]; then
              echo "ğŸ”„ Connection timeout - service may still be starting"
            else
              echo "âš ï¸ Unexpected status (HTTP $STATUS), retrying..."
            fi
            
            sleep 15
          done
          
          if [ "$HEALTH_PASSED" = "true" ]; then
            echo "health_check_passed=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Health check failed after DNS update"
            echo "ğŸ”§ This may indicate a service issue rather than DNS routing"
            echo "health_check_passed=false" >> $GITHUB_OUTPUT
          fi

      - name: Deployment summary
        if: steps.deployment_status.outputs.deployment_success == 'true'
        run: |
          echo "ğŸ“‹ Deployment Summary"
          echo "===================="
          echo "Service: ${{ env.SERVICE }}"
          echo "Image: ${{ env.IMAGE_URI }}"
          echo "Version: ${{ env.APP_VERSION }}"
          echo "Health Check: ${{ steps.health_check.outputs.health_check_passed }}"
          echo ""
          
          if [ "${{ steps.health_check.outputs.health_check_passed }}" = "true" ]; then
            echo "âœ… Service deployment completed successfully!"
            echo "ğŸŒ DNS updated and health checks passed"
          else
            echo "âš ï¸ Service deployed but health checks failed"
            echo "ğŸ”§ This may indicate a service configuration issue"
            echo "ğŸ’¡ Check ECS logs and service status"
          fi
          
          # Additional context for frontend
          if [ "${{ env.SERVICE }}" = "frontend" ] && [ "${{ env.missing_backends }}" = "true" ]; then
            echo ""
            echo "âš ï¸  IMPORTANT: Frontend is running but backend services are missing!"
            echo "ğŸ”§ API calls will fail with 502 errors until backend services are deployed"
            echo "ğŸ’¡ Use 'Deploy All Services' workflow or deploy individual backend services"
          fi
          echo "ğŸ”§ Check service logs and DNS records if issues persist"
