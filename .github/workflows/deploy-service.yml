name: Deploy Service to ECS

on:
  repository_dispatch:
    types: [deploy-service]
  workflow_dispatch:
    inputs:
      service:
        description: "Service name (frontend, catalog, user-accounts, text-search, alerts)"
        required: true
      image_uri:
        description: "Full ECR image URI"
        required: true
      container_port:
        description: "Container port (80 for frontend, 8080 for backend)"
        required: false
        default: '8080'
      desired_count:
        description: "Desired task count"
        required: false
        default: '1'
      app_version:
        description: "Application version (defaults to 'manual' for manual deployments)"
        required: false
        default: 'manual'

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ap-southeast-1
      SERVICE: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.service || github.event.inputs.service }}
      IMAGE_URI: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.image_uri || github.event.inputs.image_uri }}
      CONTAINER_PORT: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.container_port || github.event.inputs.container_port || '8080' }}
      DESIRED_COUNT: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.desired_count || github.event.inputs.desired_count || '1' }}
      APP_ENV: beta
      APP_VERSION: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.app_version || github.event.inputs.app_version || 'manual' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Auto-scale cluster if needed
        run: |
          echo "üîç Checking if cluster needs to be scaled up..."
          CURRENT_CAPACITY=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ph-shoes-services-ecs-asg \
            --region ${{ env.AWS_REGION }} \
            --query 'AutoScalingGroups[0].DesiredCapacity' \
            --output text)
          
          if [ "$CURRENT_CAPACITY" = "0" ]; then
            echo "‚ö° Cluster is at 0 capacity, scaling up to 1 instance..."
            aws autoscaling set-desired-capacity \
              --auto-scaling-group-name ph-shoes-services-ecs-asg \
              --desired-capacity 1 \
              --region ${{ env.AWS_REGION }}
            
            echo "‚è≥ Waiting 90 seconds for instance to start and register with ECS..."
            sleep 90
            echo "‚úÖ Cluster scaled up and ready for deployment"
          else
            echo "‚úÖ Cluster already has $CURRENT_CAPACITY instance(s) running"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Terraform init
        working-directory: terraform-service-deploy
        run: |
          terraform init -input=false -reconfigure \
            -backend-config="key=services-tf-state/deployments/${SERVICE}.tfstate"

      - name: Set service configuration
        id: secrets
        run: |
          # Set common configuration
          echo "log_group=/ecs/ph-shoes-services-automation-$SERVICE" >> $GITHUB_OUTPUT
          
          # Set service type and basic config
          if [ "$SERVICE" = "frontend" ]; then
            echo "exec_role=${{ secrets.FRONTEND_EXEC_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "task_role=${{ secrets.FRONTEND_TASK_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "port=80" >> $GITHUB_OUTPUT
            echo "host_port=8080" >> $GITHUB_OUTPUT
            echo "memory=128" >> $GITHUB_OUTPUT
            
            # Frontend environment (minimal)
            jq -n \
              --arg app_env "${{ env.APP_ENV }}" \
              --arg app_version "${{ env.APP_VERSION }}" \
              '{
                "APP_ENV": $app_env,
                "APP_VERSION": $app_version
              }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
          else
            # Backend services - shared configuration
            echo "exec_role=${{ secrets.BACKEND_EXEC_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "task_role=${{ secrets.BACKEND_TASK_ROLE_ARN }}" >> $GITHUB_OUTPUT
            echo "port=8080" >> $GITHUB_OUTPUT
            echo "memory=456" >> $GITHUB_OUTPUT
            
            # Set service-specific host ports and container ports
            case "$SERVICE" in
              catalog) echo "host_port=8083" >> $GITHUB_OUTPUT ;;
              user-accounts) echo "host_port=8082" >> $GITHUB_OUTPUT; echo "port=8082" >> $GITHUB_OUTPUT ;;
              text-search) echo "host_port=8084" >> $GITHUB_OUTPUT; echo "port=8084" >> $GITHUB_OUTPUT ;;
              alerts) echo "host_port=8085" >> $GITHUB_OUTPUT ;;
              *) echo "host_port=8080" >> $GITHUB_OUTPUT ;;
            esac
            
            # Shared backend environment (all secrets included)
            # Set service-specific SERVER_PORT
            case "$SERVICE" in
              user-accounts) SERVER_PORT="8082" ;;
              text-search) SERVER_PORT="8084" ;;
              *) SERVER_PORT="8080" ;;
            esac
            
            jq -n \
              --arg app_env "${{ env.APP_ENV }}" \
              --arg app_version "${{ env.APP_VERSION }}" \
              --arg aws_region "${{ env.AWS_REGION }}" \
              --arg server_port "$SERVER_PORT" \
              --arg spring_profiles "${{ secrets.SPRING_PROFILES_ACTIVE }}" \
              --arg datasource_username "${{ secrets.SPRING_DATASOURCE_USERNAME }}" \
              --arg datasource_password "${{ secrets.SPRING_DATASOURCE_PASSWORD }}" \
              --arg snowflake_account "${{ secrets.SNOWFLAKE_ACCOUNT }}" \
              --arg snowflake_warehouse "${{ secrets.SNOWFLAKE_WAREHOUSE }}" \
              --arg snowflake_database "${{ secrets.SNOWFLAKE_DATABASE }}" \
              --arg snowflake_schema "${{ secrets.SNOWFLAKE_SCHEMA }}" \
              --arg snowflake_role "${{ secrets.SNOWFLAKE_ROLE }}" \
              --arg snowflake_token "${{ secrets.SNOWFLAKE_TOKEN }}" \
              --arg hmac_pepper_b64 "${{ secrets.HMAC_PEPPER_B64 }}" \
              --arg aes_key_b64 "${{ secrets.AES_KEY_B64 }}" \
              --arg hmac_legacy_peppers_b64 "${{ secrets.HMAC_LEGACY_PEPPERS_B64 }}" \
              --arg jwt_secret "${{ secrets.JWT_SECRET }}" \
              --arg openai_api_key "${{ secrets.OPENAI_API_KEY }}" \
              --arg openai_org_id "${{ secrets.OPENAI_ORG_ID }}" \
              --arg openai_project_id "${{ secrets.OPENAI_PROJECT_ID }}" \
              '{
                "APP_ENV": $app_env,
                "APP_VERSION": $app_version,
                "AWS_REGION": $aws_region,
                "SERVER_PORT": $server_port,
                "SPRING_PROFILES_ACTIVE": $spring_profiles,
                "SPRING_DATASOURCE_USERNAME": $datasource_username,
                "SPRING_DATASOURCE_PASSWORD": $datasource_password,
                "SNOWFLAKE_ACCOUNT": $snowflake_account,
                "SNOWFLAKE_WAREHOUSE": $snowflake_warehouse,
                "SNOWFLAKE_DATABASE": $snowflake_database,
                "SNOWFLAKE_SCHEMA": $snowflake_schema,
                "SNOWFLAKE_ROLE": $snowflake_role,
                "SNOWFLAKE_TOKEN": $snowflake_token,
                "HMAC_PEPPER_B64": $hmac_pepper_b64,
                "AES_KEY_B64": $aes_key_b64,
                "HMAC_LEGACY_PEPPERS_B64": $hmac_legacy_peppers_b64,
                "JWT_SECRET": $jwt_secret,
                "OPENAI_API_KEY": $openai_api_key,
                "OPENAI_ORG_ID": $openai_org_id,
                "OPENAI_PROJECT_ID": $openai_project_id,
                "NOTIFICATION_UNSUBSCRIBE_LINK": "https://accounts.phshoesproject.com/api/v1/user-accounts/unsubscribe",
                "VERIFICATION_LINK_BASE_URL": "https://accounts.phshoesproject.com/api/v1/verify/email",
                "VERIFICATION_NOT_ME_URL": "https://accounts.phshoesproject.com/api/v1/verify/email/not-me",
                "VERIFICATION_LINK": "https://accounts.phshoesproject.com/verify"
              }' | jq -c . | sed 's/^/environment=/' >> $GITHUB_OUTPUT
          fi

      - name: Deploy via Terraform
        working-directory: terraform-service-deploy
        env:
          TF_VAR_service_id: ${{ env.SERVICE }}
          TF_VAR_service_name: ph-shoes-services-automation-${{ env.SERVICE }}
          TF_VAR_container_image: ${{ env.IMAGE_URI }}
          TF_VAR_container_port: ${{ steps.secrets.outputs.port }}
          TF_VAR_host_port: ${{ steps.secrets.outputs.host_port }}
          TF_VAR_memory: ${{ steps.secrets.outputs.memory }}
          TF_VAR_desired_count: ${{ env.DESIRED_COUNT }}
          TF_VAR_log_group_name: ${{ steps.secrets.outputs.log_group }}
          TF_VAR_execution_role_arn: ${{ steps.secrets.outputs.exec_role }}
          TF_VAR_task_role_arn: ${{ steps.secrets.outputs.task_role }}
          TF_VAR_environment: ${{ steps.secrets.outputs.environment || '{"APP_ENV":"${{ env.APP_ENV }}","APP_VERSION":"${{ env.APP_VERSION }}"}' }}
        run: |
          echo "Deploying $SERVICE with image $IMAGE_URI on port $TF_VAR_container_port (memory: $TF_VAR_memory MB)"
          terraform apply -input=false -auto-approve

      - name: Check for missing backend services (frontend only)
        if: env.SERVICE == 'frontend'
        run: |
          echo "üîç Checking if backend services are running..."
          
          # Check if any backend services are missing
          MISSING_SERVICES=""
          
          # Check each backend service
          for service in catalog user-accounts alerts; do
            RUNNING=$(aws ecs describe-services \
              --cluster ph-shoes-services-ecs \
              --services ph-shoes-services-automation-$service \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].runningCount' \
              --output text 2>/dev/null || echo "0")
            
            if [ "$RUNNING" = "0" ] || [ "$RUNNING" = "None" ]; then
              MISSING_SERVICES="$MISSING_SERVICES $service"
              echo "‚ùå Service $service is not running"
            else
              echo "‚úÖ Service $service is running ($RUNNING tasks)"
            fi
          done
          
          if [ -n "$MISSING_SERVICES" ]; then
            echo "‚ö†Ô∏è  Warning: Backend services are not running:$MISSING_SERVICES"
            echo "üí° Frontend will work but API calls may fail with 502 errors"
            echo "üîß To fix: Deploy the missing backend services or use the 'Deploy All Services' workflow"
            echo ""
            echo "missing_backends=true" >> $GITHUB_ENV
          else
            echo "‚úÖ All backend services are running"
            echo "missing_backends=false" >> $GITHUB_ENV
          fi

      - name: Wait for ECS rollout completion and trigger DNS update
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ "${{ env.SERVICE }}" = "frontend" ]; then
            echo "üîÑ Waiting for ECS rollout to complete..."
            DNS_TRIGGERED=false
            
            for i in {1..30}; do
              SERVICE_INFO=$(aws ecs describe-services \
                --cluster ph-shoes-services-ecs \
                --services ph-shoes-services-automation-frontend \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].{running:runningCount,desired:desiredCount,deployments:deployments[?status==`PRIMARY`].{status:status,rolloutState:rolloutState}}' --output json)
              
              RUNNING=$(echo $SERVICE_INFO | jq -r '.running')
              DESIRED=$(echo $SERVICE_INFO | jq -r '.desired')
              ROLLOUT_STATE=$(echo $SERVICE_INFO | jq -r '.deployments[0].rolloutState // "PENDING"')
              
              echo "ECS Status: $RUNNING/$DESIRED tasks running, Rollout: $ROLLOUT_STATE"
              
              # Start health check when rollout completes
              if [ "$RUNNING" = "$DESIRED" ] && [ "$RUNNING" != "0" ] && [ "$ROLLOUT_STATE" = "COMPLETED" ]; then
                echo "‚úÖ ECS tasks are running, checking URL health..."
                
                URL="https://phshoesproject.com"
                STATUS=$(curl -s -o /dev/null -w "%{http_code}" $URL || echo "000")
                
                if [ "$STATUS" = "200" ]; then
                  echo "‚úÖ Site is healthy (HTTP $STATUS)"
                  
                  # Additional check if backends are missing
                  if [ "${{ env.missing_backends }}" = "true" ]; then
                    echo ""
                    echo "‚ö†Ô∏è  IMPORTANT: Frontend is running but backend services are missing!"
                    echo "üîß API calls will fail with 502 errors until backend services are deployed"
                    echo "üí° Use 'Deploy All Services' workflow or deploy individual backend services"
                  fi
                  
                  exit 0
                else
                  echo "‚ùå URL returned HTTP $STATUS - Frontend should work independently!"
                  echo "üîß Frontend deployment failed - site should be accessible even without backends"
                  if [ "$STATUS" = "502" ]; then
                    echo "üí° 502 error indicates nginx configuration or container port mapping issue"
                  elif [ "$STATUS" = "522" ]; then
                    echo "üí° 522 error indicates DNS mismatch - triggering DNS update if not done yet"
                    if [ "$DNS_TRIGGERED" = "false" ]; then
                      echo "üåê Triggering DNS update to fix 522 error..."
                      gh workflow run auto-dns-update.yml || echo "‚ö†Ô∏è DNS update trigger failed"
                      DNS_TRIGGERED=true
                      echo "‚è≥ Waiting 90 seconds for DNS propagation..."
                      sleep 90
                    fi
                  fi
                  # Continue waiting instead of exiting - don't accept 502/522 as success
                fi
              fi
              
              echo "Attempt $i/30 - waiting 30s..."
              sleep 30
            done
            
            echo "‚ùå Deployment failed - site not healthy after 15 minutes"
            exit 1
          else
            echo "Non-frontend service - showing status:"
            aws ecs describe-services \
              --cluster ph-shoes-services-ecs \
              --services ph-shoes-services-automation-${{ env.SERVICE }} \
              --region ${{ env.AWS_REGION }} \
              --query 'services[0].{desired:desiredCount,running:runningCount,pending:pendingCount}'
          fi
